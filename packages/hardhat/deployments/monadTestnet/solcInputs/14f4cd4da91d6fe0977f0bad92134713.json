{
  "language": "Solidity",
  "sources": {
    "contracts/CleanChain.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\n// Useful for debugging. Remove when deploying to a live network.\n// import \"hardhat/console.sol\"; // REMOVED: console.log not needed in production\n\n/**\n * CleanChain - Decentralized Garbage Collection Verification Platform\n * A smart contract for tracking, verifying, and incentivizing neighborhood garbage collection\n * @author CleanChain Team\n */\ncontract CleanChain {\n    // State Variables\n    address public immutable owner;\n    uint256 public totalHouses = 0;\n    uint256 public totalCleaners = 0;\n    uint256 public totalCollectionEvents = 0;\n    uint256 public totalComplaints = 0;\n\n    // Data Structures as defined in PRD\n    struct House {\n        address wallet;\n        uint256 points;\n        string neighborhood;\n        uint8 residents;\n        bytes32[] collectionHashes;\n        bool isRegistered;\n        uint256 registrationTimestamp;\n    }\n\n    struct Cleaner {\n        address wallet;\n        uint256 points;\n        uint256 reputation;\n        bytes32[] collectionHashes;\n        bool isRegistered;\n        uint256 registrationTimestamp;\n        string[] assignedNeighborhoods; // Neighborhoods where cleaner is authorized\n    }\n\n    struct CollectionEvent {\n        address cleaner;\n        address house;\n        uint256 timestamp;\n        bytes32 imageHash;\n        string imageURI;\n        bool confirmedByHouse;\n        uint256 eventId;\n    }\n\n    struct Complaint {\n        address reporter;\n        bytes32 imageHash;\n        string imageURI;\n        string location;\n        string neighborhood;\n        address[] validators;\n        uint8 status; // 0 = PENDING, 1 = VALIDATED, 2 = INVALID\n        uint256 timestamp;\n        uint256 complaintId;\n    }\n\n    struct Neighborhood {\n        string name;\n        string description;\n        address admin;\n        bool isActive;\n        uint256 registrationTimestamp;\n        uint256 totalHouses;\n        uint256 totalCleaners;\n        uint256 totalCollections;\n        uint256 confirmedCollections;\n    }\n\n    // Mappings\n    mapping(address => House) public houses;\n    mapping(address => Cleaner) public cleaners;\n    mapping(uint256 => CollectionEvent) public collectionEvents;\n    mapping(uint256 => Complaint) public complaints;\n    mapping(string => address[]) public neighborhoodHouses; // neighborhood => array of house addresses\n    mapping(string => address[]) public neighborhoodCleaners; // neighborhood => array of cleaner addresses\n    mapping(string => Neighborhood) public neighborhoods; // neighborhood name => Neighborhood struct\n    mapping(address => bool) public neighborhoodAdmins; // address => is neighborhood admin\n    mapping(string => mapping(address => bool)) public cleanerNeighborhoodAccess; // neighborhood => cleaner => authorized\n\n    // Arrays for enumeration\n    address[] public registeredHouses;\n    address[] public registeredCleaners;\n    string[] public registeredNeighborhoods;\n\n    // Contract state\n    bool public contractPaused = false;\n\n    // Events\n    event HouseRegistered(address indexed wallet, string neighborhood, uint8 residents, uint256 timestamp);\n    event CleanerRegistered(address indexed wallet, uint256 timestamp);\n    event CollectionEventCreated(\n        uint256 indexed eventId,\n        address indexed cleaner,\n        address indexed house,\n        bytes32 imageHash,\n        uint256 timestamp\n    );\n    event CollectionEventConfirmed(uint256 indexed eventId, address indexed house);\n    event ComplaintCreated(\n        uint256 indexed complaintId,\n        address indexed reporter,\n        string location,\n        string neighborhood,\n        bytes32 imageHash\n    );\n    event PointsAwarded(address indexed recipient, uint256 points, string reason);\n    event NeighborhoodRegistered(string indexed neighborhoodName, address indexed admin, uint256 timestamp);\n    event NeighborhoodAdminAssigned(string indexed neighborhoodName, address indexed admin);\n    event CleanerAssignedToNeighborhood(address indexed cleaner, string neighborhoodName);\n    event CleanerRemovedFromNeighborhood(address indexed cleaner, string neighborhoodName);\n    event ContractPaused(bool paused);\n    event NeighborhoodStatusChanged(string indexed neighborhoodName, bool isActive);\n\n    // Constructor\n    constructor(address _owner) {\n        owner = _owner;\n        // console.log(\"CleanChain contract deployed by:\", _owner); // REMOVED\n    }\n\n    // Modifiers\n    modifier isOwner() {\n        require(msg.sender == owner, \"Not the owner\");\n        _;\n    }\n\n    modifier onlyRegisteredHouse() {\n        require(houses[msg.sender].isRegistered, \"House not registered\");\n        _;\n    }\n\n    modifier onlyRegisteredCleaner() {\n        require(cleaners[msg.sender].isRegistered, \"Cleaner not registered\");\n        _;\n    }\n\n    modifier validNeighborhood(string memory _neighborhood) {\n        require(bytes(_neighborhood).length > 0, \"Neighborhood cannot be empty\");\n        require(neighborhoods[_neighborhood].isActive, \"Neighborhood not active or doesn't exist\");\n        _;\n    }\n\n    modifier validResidents(uint8 _residents) {\n        require(_residents > 0 && _residents <= 20, \"Invalid number of residents\");\n        _;\n    }\n\n    modifier whenNotPaused() {\n        require(!contractPaused, \"Contract is paused\");\n        _;\n    }\n\n    modifier onlyNeighborhoodAdmin(string memory _neighborhood) {\n        require(\n            msg.sender == owner || \n            (neighborhoods[_neighborhood].admin == msg.sender && neighborhoodAdmins[msg.sender]),\n            \"Not authorized neighborhood admin\"\n        );\n        _;\n    }\n\n    modifier cleanerAuthorizedInNeighborhood(address _cleaner, string memory _neighborhood) {\n        require(\n            cleanerNeighborhoodAccess[_neighborhood][_cleaner] || \n            neighborhoods[_neighborhood].admin == _cleaner,\n            \"Cleaner not authorized in this neighborhood\"\n        );\n        _;\n    }\n\n    // Neighborhood Management Functions\n    /**\n     * Register a new neighborhood with admin\n     * @param _name Name of the neighborhood\n     * @param _description Description of the neighborhood\n     * @param _admin Address of the neighborhood admin\n     */\n    function registerNeighborhood(\n        string memory _name,\n        string memory _description,\n        address _admin\n    ) \n        external \n        whenNotPaused\n    {\n        require(bytes(_name).length > 0, \"Neighborhood name cannot be empty\");\n        require(bytes(_description).length > 0, \"Description cannot be empty\");\n        require(_admin != address(0), \"Invalid admin address\");\n        require(bytes(neighborhoods[_name].name).length == 0, \"Neighborhood already exists\"); // FIXED: Proper check for existing neighborhood\n        \n        // Create new neighborhood\n        Neighborhood storage newNeighborhood = neighborhoods[_name];\n        newNeighborhood.name = _name;\n        newNeighborhood.description = _description;\n        newNeighborhood.admin = _admin;\n        newNeighborhood.isActive = true;\n        newNeighborhood.registrationTimestamp = block.timestamp;\n        \n        // Set admin permissions\n        neighborhoodAdmins[_admin] = true;\n        \n        // Add to enumeration array\n        registeredNeighborhoods.push(_name);\n        \n        // console.log(\"Neighborhood registered:\", _name, \"with admin:\", _admin); // REMOVED\n        emit NeighborhoodRegistered(_name, _admin, block.timestamp);\n    }\n\n    /**\n     * Assign or change neighborhood admin\n     * @param _neighborhood Name of the neighborhood\n     * @param _newAdmin Address of the new admin\n     */\n    function assignNeighborhoodAdmin(\n        string memory _neighborhood,\n        address _newAdmin\n    ) \n        external \n        whenNotPaused\n    {\n        require(neighborhoods[_neighborhood].isActive, \"Neighborhood doesn't exist\");\n        require(_newAdmin != address(0), \"Invalid admin address\");\n        \n        address oldAdmin = neighborhoods[_neighborhood].admin;\n        \n        // FIXED: Only remove admin permissions if they're not admin of other neighborhoods\n        if (oldAdmin != _newAdmin && oldAdmin != owner) {\n            bool isAdminOfOtherNeighborhoods = false;\n            for (uint256 i = 0; i < registeredNeighborhoods.length; i++) {\n                string memory neighName = registeredNeighborhoods[i];\n                if (keccak256(abi.encodePacked(neighName)) != keccak256(abi.encodePacked(_neighborhood)) &&\n                    neighborhoods[neighName].admin == oldAdmin) {\n                    isAdminOfOtherNeighborhoods = true;\n                    break;\n                }\n            }\n            if (!isAdminOfOtherNeighborhoods) {\n                neighborhoodAdmins[oldAdmin] = false;\n            }\n        }\n        \n        // Set new admin\n        neighborhoods[_neighborhood].admin = _newAdmin;\n        neighborhoodAdmins[_newAdmin] = true;\n        \n        emit NeighborhoodAdminAssigned(_neighborhood, _newAdmin);\n    }\n\n    /**\n     * Activate or deactivate a neighborhood\n     * @param _neighborhood Name of the neighborhood\n     * @param _isActive New status for the neighborhood\n     */\n    function setNeighborhoodStatus(\n        string memory _neighborhood,\n        bool _isActive\n    ) \n        external \n        onlyNeighborhoodAdmin(_neighborhood)\n        whenNotPaused\n    {\n        require(bytes(neighborhoods[_neighborhood].name).length > 0, \"Neighborhood doesn't exist\");\n        neighborhoods[_neighborhood].isActive = _isActive;\n        \n        emit NeighborhoodStatusChanged(_neighborhood, _isActive);\n    }\n\n    /**\n     * Assign cleaner to neighborhood (by admin or owner)\n     * @param _cleaner Address of the cleaner\n     * @param _neighborhood Name of the neighborhood\n     */\n    function assignCleanerToNeighborhood(\n        address _cleaner,\n        string memory _neighborhood\n    ) \n        external \n        onlyNeighborhoodAdmin(_neighborhood)\n        whenNotPaused\n    {\n        require(cleaners[_cleaner].isRegistered, \"Cleaner not registered\");\n        require(neighborhoods[_neighborhood].isActive, \"Neighborhood not active\");\n        require(!cleanerNeighborhoodAccess[_neighborhood][_cleaner], \"Cleaner already assigned\");\n        \n        cleanerNeighborhoodAccess[_neighborhood][_cleaner] = true;\n        cleaners[_cleaner].assignedNeighborhoods.push(_neighborhood);\n        neighborhoodCleaners[_neighborhood].push(_cleaner);\n        neighborhoods[_neighborhood].totalCleaners++;\n        \n        emit CleanerAssignedToNeighborhood(_cleaner, _neighborhood);\n    }\n\n    /**\n     * Remove cleaner from neighborhood\n     * @param _cleaner Address of the cleaner\n     * @param _neighborhood Name of the neighborhood\n     */\n    function removeCleanerFromNeighborhood(\n        address _cleaner,\n        string memory _neighborhood\n    ) \n        external \n        onlyNeighborhoodAdmin(_neighborhood)\n        whenNotPaused\n    {\n        require(cleanerNeighborhoodAccess[_neighborhood][_cleaner], \"Cleaner not assigned to neighborhood\");\n        \n        cleanerNeighborhoodAccess[_neighborhood][_cleaner] = false;\n        \n        // Remove from cleaner's assigned neighborhoods array\n        string[] storage assigned = cleaners[_cleaner].assignedNeighborhoods;\n        for (uint256 i = 0; i < assigned.length; i++) {\n            if (keccak256(abi.encodePacked(assigned[i])) == keccak256(abi.encodePacked(_neighborhood))) {\n                assigned[i] = assigned[assigned.length - 1];\n                assigned.pop();\n                break;\n            }\n        }\n        \n        // FIXED: Remove from neighborhood cleaners array\n        address[] storage neighborhoodCleanersList = neighborhoodCleaners[_neighborhood];\n        for (uint256 i = 0; i < neighborhoodCleanersList.length; i++) {\n            if (neighborhoodCleanersList[i] == _cleaner) {\n                neighborhoodCleanersList[i] = neighborhoodCleanersList[neighborhoodCleanersList.length - 1];\n                neighborhoodCleanersList.pop();\n                break;\n            }\n        }\n        \n        neighborhoods[_neighborhood].totalCleaners--;\n        \n        emit CleanerRemovedFromNeighborhood(_cleaner, _neighborhood);\n    }\n\n    // House Registration Functions\n    /**\n     * Register a house with wallet public key and metadata\n     * @param _neighborhood The neighborhood where the house is located\n     * @param _residents Number of residents in the house\n     */\n    function registerHouse(\n        string memory _neighborhood,\n        uint8 _residents\n    ) \n        external \n        validNeighborhood(_neighborhood)\n        validResidents(_residents)\n        whenNotPaused\n    {\n        require(!houses[msg.sender].isRegistered, \"House already registered\");\n        \n        // Create new house\n        House storage newHouse = houses[msg.sender];\n        newHouse.wallet = msg.sender;\n        newHouse.points = 0;\n        newHouse.neighborhood = _neighborhood;\n        newHouse.residents = _residents;\n        newHouse.isRegistered = true;\n        newHouse.registrationTimestamp = block.timestamp;\n\n        // Add to arrays for enumeration\n        registeredHouses.push(msg.sender);\n        neighborhoodHouses[_neighborhood].push(msg.sender);\n        \n        // Update neighborhood statistics\n        neighborhoods[_neighborhood].totalHouses++;\n        \n        // Increment counter\n        totalHouses++;\n\n        // Award registration points\n        awardPoints(msg.sender, 10, \"House Registration\");\n\n        // console.log(\"House registered:\", msg.sender, \"in neighborhood:\", _neighborhood); // REMOVED\n        emit HouseRegistered(msg.sender, _neighborhood, _residents, block.timestamp);\n    }\n\n    /**\n     * Register a cleaner with wallet public key\n     */\n    function registerCleaner() external whenNotPaused {\n        require(!cleaners[msg.sender].isRegistered, \"Cleaner already registered\");\n        require(!houses[msg.sender].isRegistered, \"Address already registered as house\");\n        \n        // Create new cleaner\n        Cleaner storage newCleaner = cleaners[msg.sender];\n        newCleaner.wallet = msg.sender;\n        newCleaner.points = 0;\n        newCleaner.reputation = 100; // Start with base reputation\n        newCleaner.isRegistered = true;\n        newCleaner.registrationTimestamp = block.timestamp;\n\n        // Add to array for enumeration\n        registeredCleaners.push(msg.sender);\n        \n        // Increment counter\n        totalCleaners++;\n\n        // Award registration points\n        awardPoints(msg.sender, 10, \"Cleaner Registration\");\n\n        // console.log(\"Cleaner registered:\", msg.sender); // REMOVED\n        emit CleanerRegistered(msg.sender, block.timestamp);\n    }\n\n    // Collection Event Functions\n    /**\n     * Log garbage collection by cleaner with image proof\n     * @param _houseAddress Address of the house where garbage was collected\n     * @param _imageHash Hash of the image taken as proof of collection\n     * @param _imageURI URI pointing to the off-chain stored image\n     */\n    function logGarbageCollection(\n        address _houseAddress,\n        bytes32 _imageHash,\n        string memory _imageURI\n    ) \n        external \n        onlyRegisteredCleaner\n        whenNotPaused\n    {\n        require(houses[_houseAddress].isRegistered, \"House not registered\");\n        require(_imageHash != bytes32(0), \"Image hash cannot be empty\");\n        require(bytes(_imageURI).length > 0, \"Image URI cannot be empty\");\n        \n        string memory houseNeighborhood = houses[_houseAddress].neighborhood;\n        \n        // Check if cleaner is authorized in this neighborhood\n        require(\n            cleanerNeighborhoodAccess[houseNeighborhood][msg.sender] ||\n            neighborhoods[houseNeighborhood].admin == msg.sender ||\n            msg.sender == owner,\n            \"Cleaner not authorized in this neighborhood\"\n        );\n        \n        // Create new collection event\n        uint256 eventId = totalCollectionEvents;\n        CollectionEvent storage newEvent = collectionEvents[eventId];\n        newEvent.cleaner = msg.sender;\n        newEvent.house = _houseAddress;\n        newEvent.timestamp = block.timestamp;\n        newEvent.imageHash = _imageHash;\n        newEvent.imageURI = _imageURI;\n        newEvent.confirmedByHouse = false;\n        newEvent.eventId = eventId;\n\n        // Add hash to cleaner's collection history\n        cleaners[msg.sender].collectionHashes.push(_imageHash);\n        \n        // Update neighborhood statistics\n        neighborhoods[houseNeighborhood].totalCollections++;\n        \n        // Increment counter\n        totalCollectionEvents++;\n\n        // Award points to cleaner\n        awardPoints(msg.sender, 20, \"Garbage Collection\");\n\n        // console.log(\"Garbage collection logged by cleaner:\", msg.sender, \"at house:\", _houseAddress); // REMOVED\n        emit CollectionEventCreated(eventId, msg.sender, _houseAddress, _imageHash, block.timestamp);\n    }\n\n    /**\n     * Confirm garbage collection by house with validation\n     * @param _eventId ID of the collection event to confirm\n     * @param _imageHash Hash of the validation image taken by the house\n     * @param _imageURI URI pointing to the house's validation image\n     */\n    function confirmGarbageCollection(\n        uint256 _eventId,\n        bytes32 _imageHash,\n        string memory _imageURI\n    ) \n        external \n        onlyRegisteredHouse\n        whenNotPaused\n    {\n        require(_eventId < totalCollectionEvents, \"Invalid event ID\");\n        require(_imageHash != bytes32(0), \"Image hash cannot be empty\");\n        require(bytes(_imageURI).length > 0, \"Image URI cannot be empty\");\n        \n        CollectionEvent storage collectionEvent = collectionEvents[_eventId];\n        require(collectionEvent.house == msg.sender, \"Not authorized to confirm this event\");\n        require(!collectionEvent.confirmedByHouse, \"Event already confirmed\");\n        \n        // Confirm the event\n        collectionEvent.confirmedByHouse = true;\n        \n        // FIXED: Only add the house's validation hash, not the cleaner's proof hash\n        houses[msg.sender].collectionHashes.push(_imageHash);\n        \n        // Update neighborhood statistics\n        string memory houseNeighborhood = houses[msg.sender].neighborhood;\n        neighborhoods[houseNeighborhood].confirmedCollections++;\n        \n        // Award bonus points to both cleaner and house for confirmed collection\n        awardPoints(collectionEvent.cleaner, 10, \"Confirmed Collection Bonus\");\n        awardPoints(msg.sender, 15, \"Collection Validation\");\n        \n        // Increase cleaner's reputation for confirmed work\n        cleaners[collectionEvent.cleaner].reputation += 5;\n\n        emit CollectionEventConfirmed(_eventId, msg.sender);\n    }\n\n    /**\n     * Get collection event details by ID\n     * @param _eventId ID of the collection event\n     * @return CollectionEvent struct containing event details\n     */\n    function getCollectionEvent(uint256 _eventId) external view returns (CollectionEvent memory) {\n        require(_eventId < totalCollectionEvents, \"Invalid event ID\");\n        return collectionEvents[_eventId];\n    }\n\n    /**\n     * Get collection events for a house with pagination to avoid gas issues\n     * @param _houseAddress Address of the house\n     * @param _offset Starting index for pagination\n     * @param _limit Maximum number of events to return\n     * @return Array of event IDs for the house\n     * @return Total count of events for this house\n     */\n    function getHouseCollectionEventsPaginated(\n        address _houseAddress, \n        uint256 _offset, \n        uint256 _limit\n    ) external view returns (uint256[] memory, uint256) {\n        require(houses[_houseAddress].isRegistered, \"House not registered\");\n        require(_limit > 0 && _limit <= 100, \"Invalid limit: must be between 1 and 100\");\n        \n        // Count total events first\n        uint256 totalCount = 0;\n        for (uint256 i = 0; i < totalCollectionEvents; i++) {\n            if (collectionEvents[i].house == _houseAddress) {\n                totalCount++;\n            }\n        }\n        \n        if (_offset >= totalCount) {\n            return (new uint256[](0), totalCount);\n        }\n        \n        uint256 resultSize = _limit;\n        if (_offset + _limit > totalCount) {\n            resultSize = totalCount - _offset;\n        }\n        \n        uint256[] memory eventIds = new uint256[](resultSize);\n        uint256 currentIndex = 0;\n        uint256 matchedCount = 0;\n        \n        for (uint256 i = 0; i < totalCollectionEvents && currentIndex < resultSize; i++) {\n            if (collectionEvents[i].house == _houseAddress) {\n                if (matchedCount >= _offset) {\n                    eventIds[currentIndex] = i;\n                    currentIndex++;\n                }\n                matchedCount++;\n            }\n        }\n        \n        return (eventIds, totalCount);\n    }\n\n    /**\n     * Get collection events for a cleaner with pagination to avoid gas issues\n     * @param _cleanerAddress Address of the cleaner\n     * @param _offset Starting index for pagination\n     * @param _limit Maximum number of events to return\n     * @return Array of event IDs for the cleaner\n     * @return Total count of events for this cleaner\n     */\n    function getCleanerCollectionEventsPaginated(\n        address _cleanerAddress, \n        uint256 _offset, \n        uint256 _limit\n    ) external view returns (uint256[] memory, uint256) {\n        require(cleaners[_cleanerAddress].isRegistered, \"Cleaner not registered\");\n        require(_limit > 0 && _limit <= 100, \"Invalid limit: must be between 1 and 100\");\n        \n        // Count total events first\n        uint256 totalCount = 0;\n        for (uint256 i = 0; i < totalCollectionEvents; i++) {\n            if (collectionEvents[i].cleaner == _cleanerAddress) {\n                totalCount++;\n            }\n        }\n        \n        if (_offset >= totalCount) {\n            return (new uint256[](0), totalCount);\n        }\n        \n        uint256 resultSize = _limit;\n        if (_offset + _limit > totalCount) {\n            resultSize = totalCount - _offset;\n        }\n        \n        uint256[] memory eventIds = new uint256[](resultSize);\n        uint256 currentIndex = 0;\n        uint256 matchedCount = 0;\n        \n        for (uint256 i = 0; i < totalCollectionEvents && currentIndex < resultSize; i++) {\n            if (collectionEvents[i].cleaner == _cleanerAddress) {\n                if (matchedCount >= _offset) {\n                    eventIds[currentIndex] = i;\n                    currentIndex++;\n                }\n                matchedCount++;\n            }\n        }\n        \n        return (eventIds, totalCount);\n    }\n\n    /**\n     * Get collection statistics for a house\n     * @param _houseAddress Address of the house\n     * @return totalEvents Total collection events for the house\n     * @return confirmedEvents Number of confirmed collection events\n     * @return pendingEvents Number of pending (unconfirmed) collection events\n     */\n    function getHouseCollectionStats(address _houseAddress) \n        external \n        view \n        returns (uint256 totalEvents, uint256 confirmedEvents, uint256 pendingEvents) \n    {\n        require(houses[_houseAddress].isRegistered, \"House not registered\");\n        \n        for (uint256 i = 0; i < totalCollectionEvents; i++) {\n            if (collectionEvents[i].house == _houseAddress) {\n                totalEvents++;\n                if (collectionEvents[i].confirmedByHouse) {\n                    confirmedEvents++;\n                } else {\n                    pendingEvents++;\n                }\n            }\n        }\n    }\n\n    /**\n     * Get collection statistics for a cleaner\n     * @param _cleanerAddress Address of the cleaner\n     * @return totalEvents Total collection events by the cleaner\n     * @return confirmedEvents Number of confirmed collection events\n     * @return confirmationRate Percentage of confirmed collections (0-100)\n     */\n    function getCleanerCollectionStats(address _cleanerAddress) \n        external \n        view \n        returns (uint256 totalEvents, uint256 confirmedEvents, uint256 confirmationRate) \n    {\n        require(cleaners[_cleanerAddress].isRegistered, \"Cleaner not registered\");\n        \n        for (uint256 i = 0; i < totalCollectionEvents; i++) {\n            if (collectionEvents[i].cleaner == _cleanerAddress) {\n                totalEvents++;\n                if (collectionEvents[i].confirmedByHouse) {\n                    confirmedEvents++;\n                }\n            }\n        }\n        \n        if (totalEvents > 0) {\n            confirmationRate = (confirmedEvents * 100) / totalEvents;\n        }\n    }\n\n    // Neighborhood Query Functions\n    /**\n     * Get neighborhood information\n     * @param _neighborhood Name of the neighborhood\n     * @return Neighborhood struct containing all neighborhood information\n     */\n    function getNeighborhood(string memory _neighborhood) external view returns (Neighborhood memory) {\n        require(bytes(neighborhoods[_neighborhood].name).length > 0, \"Neighborhood doesn't exist\");\n        return neighborhoods[_neighborhood];\n    }\n\n    /**\n     * Get all registered neighborhoods\n     * @return Array of neighborhood names\n     */\n    function getAllNeighborhoods() external view returns (string[] memory) {\n        return registeredNeighborhoods;\n    }\n\n    /**\n     * Get neighborhoods assigned to a cleaner\n     * @param _cleanerAddress Address of the cleaner\n     * @return Array of neighborhood names where cleaner is authorized\n     */\n    function getCleanerNeighborhoods(address _cleanerAddress) external view returns (string[] memory) {\n        require(cleaners[_cleanerAddress].isRegistered, \"Cleaner not registered\");\n        return cleaners[_cleanerAddress].assignedNeighborhoods;\n    }\n\n    /**\n     * Check if cleaner is authorized in neighborhood\n     * @param _cleaner Address of the cleaner\n     * @param _neighborhood Name of the neighborhood\n     * @return Boolean indicating if cleaner is authorized\n     */\n    function isCleanerAuthorized(address _cleaner, string memory _neighborhood) external view returns (bool) {\n        return cleanerNeighborhoodAccess[_neighborhood][_cleaner] || \n               neighborhoods[_neighborhood].admin == _cleaner ||\n               _cleaner == owner;\n    }\n\n    /**\n     * Check if address is a neighborhood admin\n     * @param _address Address to check\n     * @return Boolean indicating if address is a neighborhood admin\n     */\n    function isNeighborhoodAdmin(address _address) external view returns (bool) {\n        return neighborhoodAdmins[_address] || _address == owner;\n    }\n\n    /**\n     * Get neighborhood statistics\n     * @param _neighborhood Name of the neighborhood\n     * @return totalHouses Number of houses in neighborhood\n     * @return totalCleaners Number of cleaners assigned to neighborhood\n     * @return totalCollections Total collection events in neighborhood\n     * @return confirmedCollections Number of confirmed collections\n     * @return confirmationRate Percentage of confirmed collections (0-100)\n     */\n    function getNeighborhoodStats(string memory _neighborhood) \n        external \n        view \n        returns (\n            uint256 totalHouses,\n            uint256 totalCleaners,\n            uint256 totalCollections,\n            uint256 confirmedCollections,\n            uint256 confirmationRate\n        ) \n    {\n        require(bytes(neighborhoods[_neighborhood].name).length > 0, \"Neighborhood doesn't exist\");\n        \n        Neighborhood memory neighborhood = neighborhoods[_neighborhood];\n        totalHouses = neighborhood.totalHouses;\n        totalCleaners = neighborhood.totalCleaners;\n        totalCollections = neighborhood.totalCollections;\n        confirmedCollections = neighborhood.confirmedCollections;\n        \n        if (totalCollections > 0) {\n            confirmationRate = (confirmedCollections * 100) / totalCollections;\n        }\n    }\n\n    // Utility Functions\n    /**\n     * Award points to a user and emit event\n     * @param _recipient Address to receive points\n     * @param _points Number of points to award\n     * @param _reason Reason for awarding points\n     */\n    function awardPoints(address _recipient, uint256 _points, string memory _reason) internal {\n        if (houses[_recipient].isRegistered) {\n            houses[_recipient].points += _points;\n        } else if (cleaners[_recipient].isRegistered) {\n            cleaners[_recipient].points += _points;\n        }\n        \n        emit PointsAwarded(_recipient, _points, _reason);\n    }\n\n    // View Functions\n    /**\n     * Get house information by address\n     * @param _houseAddress Address of the house\n     * @return House struct containing all house information\n     */\n    function getHouse(address _houseAddress) external view returns (House memory) {\n        require(houses[_houseAddress].isRegistered, \"House not registered\");\n        return houses[_houseAddress];\n    }\n\n    /**\n     * Get cleaner information by address\n     * @param _cleanerAddress Address of the cleaner\n     * @return Cleaner struct containing all cleaner information\n     */\n    function getCleaner(address _cleanerAddress) external view returns (Cleaner memory) {\n        require(cleaners[_cleanerAddress].isRegistered, \"Cleaner not registered\");\n        return cleaners[_cleanerAddress];\n    }\n\n    /**\n     * Get all houses in a neighborhood\n     * @param _neighborhood Name of the neighborhood\n     * @return Array of house addresses in the neighborhood\n     */\n    function getHousesInNeighborhood(string memory _neighborhood) external view returns (address[] memory) {\n        return neighborhoodHouses[_neighborhood];\n    }\n\n    /**\n     * Get all cleaners in a neighborhood\n     * @param _neighborhood Name of the neighborhood\n     * @return Array of cleaner addresses in the neighborhood\n     */\n    function getCleanersInNeighborhood(string memory _neighborhood) external view returns (address[] memory) {\n        return neighborhoodCleaners[_neighborhood];\n    }\n\n    /**\n     * Get total number of registered houses\n     * @return Total number of houses\n     */\n    function getTotalHouses() external view returns (uint256) {\n        return totalHouses;\n    }\n\n    /**\n     * Get total number of registered cleaners\n     * @return Total number of cleaners\n     */\n    function getTotalCleaners() external view returns (uint256) {\n    \n        return totalCleaners;\n    }\n\n    /**\n     * Check if an address is a registered house\n     * @param _address Address to check\n     * @return Boolean indicating if address is a registered house\n     */\n    function isRegisteredHouse(address _address) external view returns (bool) {\n        return houses[_address].isRegistered;\n    }\n\n    /**\n     * Check if an address is a registered cleaner\n     * @param _address Address to check\n     * @return Boolean indicating if address is a registered cleaner\n     */\n    function isRegisteredCleaner(address _address) external view returns (bool) {\n        return cleaners[_address].isRegistered;\n    }\n\n    /**\n     * Get all registered house addresses\n     * @return Array of all registered house addresses\n     */\n    function getAllRegisteredHouses() external view returns (address[] memory) {\n        return registeredHouses;\n    }\n\n    /**\n     * Get all registered cleaner addresses\n     * @return Array of all registered cleaner addresses\n     */\n    function getAllRegisteredCleaners() external view returns (address[] memory) {\n        return registeredCleaners;\n    }\n\n    // Owner Functions\n    /**\n     * Update house points (only owner)\n     * @param _houseAddress Address of the house\n     * @param _points New points value\n     */\n    function updateHousePoints(address _houseAddress, uint256 _points) external isOwner {\n        require(houses[_houseAddress].isRegistered, \"House not registered\");\n        houses[_houseAddress].points = _points;\n    }\n\n    /**\n     * Update cleaner reputation (only owner)\n     * @param _cleanerAddress Address of the cleaner\n     * @param _reputation New reputation value\n     */\n    function updateCleanerReputation(address _cleanerAddress, uint256 _reputation) external isOwner {\n        require(cleaners[_cleanerAddress].isRegistered, \"Cleaner not registered\");\n        cleaners[_cleanerAddress].reputation = _reputation;\n    }\n\n    // Administrative Functions\n    /**\n     * Pause or unpause the contract (emergency function)\n     * @param _paused New pause state\n     */\n    function pauseContract(bool _paused) external isOwner {\n        contractPaused = _paused;\n        emit ContractPaused(_paused);\n    }\n\n    /**\n     * Batch assign multiple cleaners to a neighborhood\n     * @param _cleaners Array of cleaner addresses\n     * @param _neighborhood Name of the neighborhood\n     */\n    function batchAssignCleanersToNeighborhood(\n        address[] memory _cleaners,\n        string memory _neighborhood\n    ) \n        external \n        onlyNeighborhoodAdmin(_neighborhood)\n        whenNotPaused\n    {\n        require(_cleaners.length > 0, \"No cleaners provided\");\n        require(neighborhoods[_neighborhood].isActive, \"Neighborhood not active\");\n        \n        for (uint256 i = 0; i < _cleaners.length; i++) {\n            address cleaner = _cleaners[i];\n            if (cleaners[cleaner].isRegistered && !cleanerNeighborhoodAccess[_neighborhood][cleaner]) {\n                cleanerNeighborhoodAccess[_neighborhood][cleaner] = true;\n                cleaners[cleaner].assignedNeighborhoods.push(_neighborhood);\n                neighborhoodCleaners[_neighborhood].push(cleaner); // FIXED: Add to neighborhood cleaners array\n                neighborhoods[_neighborhood].totalCleaners++;\n                \n                emit CleanerAssignedToNeighborhood(cleaner, _neighborhood);\n            }\n        }\n    }\n\n    /**\n     * Batch remove multiple cleaners from a neighborhood\n     * @param _cleaners Array of cleaner addresses\n     * @param _neighborhood Name of the neighborhood\n     */\n    function batchRemoveCleanersFromNeighborhood(\n        address[] memory _cleaners,\n        string memory _neighborhood\n    ) \n        external \n        onlyNeighborhoodAdmin(_neighborhood)\n        whenNotPaused\n    {\n        require(_cleaners.length > 0, \"No cleaners provided\");\n        \n        for (uint256 i = 0; i < _cleaners.length; i++) {\n            address cleaner = _cleaners[i];\n            if (cleanerNeighborhoodAccess[_neighborhood][cleaner]) {\n                cleanerNeighborhoodAccess[_neighborhood][cleaner] = false;\n                \n                // Remove from cleaner's assigned neighborhoods array\n                string[] storage assigned = cleaners[cleaner].assignedNeighborhoods;\n                for (uint256 j = 0; j < assigned.length; j++) {\n                    if (keccak256(abi.encodePacked(assigned[j])) == keccak256(abi.encodePacked(_neighborhood))) {\n                        assigned[j] = assigned[assigned.length - 1];\n                        assigned.pop();\n                        break;\n                    }\n                }\n                \n                // FIXED: Remove from neighborhood cleaners array\n                address[] storage neighborhoodCleanersList = neighborhoodCleaners[_neighborhood];\n                for (uint256 k = 0; k < neighborhoodCleanersList.length; k++) {\n                    if (neighborhoodCleanersList[k] == cleaner) {\n                        neighborhoodCleanersList[k] = neighborhoodCleanersList[neighborhoodCleanersList.length - 1];\n                        neighborhoodCleanersList.pop();\n                        break;\n                    }\n                }\n                \n                neighborhoods[_neighborhood].totalCleaners--;\n                emit CleanerRemovedFromNeighborhood(cleaner, _neighborhood);\n            }\n        }\n    }\n\n    /**\n     * Get contract pause status\n     * @return Boolean indicating if contract is paused\n     */\n    function isPaused() external view returns (bool) {\n        return contractPaused;\n    }\n\n    /**\n     * Get total number of registered neighborhoods\n     * @return Total number of neighborhoods\n     */\n    function getTotalNeighborhoods() external view returns (uint256) {\n        return registeredNeighborhoods.length;\n    }\n\n    /**\n     * Function that allows the contract to receive ETH\n     */\n    receive() external payable {}\n\n    /**\n     * FIXED: Validate that a neighborhood exists before operations\n     * @param _neighborhood Name of the neighborhood to check\n     * @return Boolean indicating if neighborhood exists and is active\n     */\n    function validateNeighborhoodExists(string memory _neighborhood) external view returns (bool) {\n        return bytes(neighborhoods[_neighborhood].name).length > 0 && neighborhoods[_neighborhood].isActive;\n    }\n\n    /**\n     * FIXED: Check for duplicate cleaner assignment more efficiently\n     * @param _cleaner Address of the cleaner\n     * @param _neighborhood Name of the neighborhood\n     * @return Boolean indicating if cleaner is already assigned\n     */\n    function isCleanerAlreadyAssigned(address _cleaner, string memory _neighborhood) external view returns (bool) {\n        return cleanerNeighborhoodAccess[_neighborhood][_cleaner];\n    }\n\n    /**\n     * Get all collection events for a specific house (DEPRECATED - use paginated version)\n     * @param _houseAddress Address of the house\n     * @return Array of event IDs for the house\n     * @dev This function may run out of gas with large datasets. Use getHouseCollectionEventsPaginated instead.\n     */\n    function getHouseCollectionEvents(address _houseAddress) external view returns (uint256[] memory) {\n        require(houses[_houseAddress].isRegistered, \"House not registered\");\n        \n        uint256[] memory eventIds = new uint256[](totalCollectionEvents);\n        uint256 count = 0;\n        \n        for (uint256 i = 0; i < totalCollectionEvents; i++) {\n            if (collectionEvents[i].house == _houseAddress) {\n                eventIds[count] = i;\n                count++;\n            }\n        }\n        \n        // Create properly sized array\n        uint256[] memory result = new uint256[](count);\n        for (uint256 i = 0; i < count; i++) {\n            result[i] = eventIds[i];\n        }\n        \n        return result;\n    }\n\n    /**\n     * Get all collection events for a specific cleaner (DEPRECATED - use paginated version)\n     * @param _cleanerAddress Address of the cleaner\n     * @return Array of event IDs for the cleaner\n     * @dev This function may run out of gas with large datasets. Use getCleanerCollectionEventsPaginated instead.\n     */\n    function getCleanerCollectionEvents(address _cleanerAddress) external view returns (uint256[] memory) {\n        require(cleaners[_cleanerAddress].isRegistered, \"Cleaner not registered\");\n        \n        uint256[] memory eventIds = new uint256[](totalCollectionEvents);\n        uint256 count = 0;\n        \n        for (uint256 i = 0; i < totalCollectionEvents; i++) {\n            if (collectionEvents[i].cleaner == _cleanerAddress) {\n                eventIds[count] = i;\n                count++;\n            }\n        }\n        \n        // Create properly sized array\n        uint256[] memory result = new uint256[](count);\n        for (uint256 i = 0; i < count; i++) {\n            result[i] = eventIds[i];\n        }\n        \n        return result;\n    }\n} "
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}